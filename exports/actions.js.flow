/**
 * Flowtype definitions for actions
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.8.0
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 * @flow
 */

import {
  Action,
  Event,
  EventObject,
  SendAction,
  SendActionOptions,
  CancelAction,
  ActionObject,
  Assigner,
  AssignAction,
  ActionFunction,
  ActionFunctionMap,
  ActivityActionObject,
  ActionTypes,
  ActivityDefinition,
  RaiseEvent,
  DoneEvent,
  ErrorExecutionEvent,
  DoneEventObject,
  SendExpr,
  SendActionObject,
  OmniEventObject
} from "./types";
import * as actionTypes from "./actionTypes";
declare export { actionTypes };
declare export var initEvent: {
  type: typeof ActionTypes.Init
};
declare export function toEventObject<TEvent: EventObject>(
  event: Event<TEvent>,
  payload?: Record<string, any> & {
    type?: empty
  }
): TEvent;
declare export function toActionObject<TContext, TEvent: EventObject>(
  action: Action<TContext, TEvent>,
  actionFunctionMap?: ActionFunctionMap<TContext, TEvent>
): ActionObject<TContext, TEvent>;
declare export function toActivityDefinition<TContext, TEvent: EventObject>(
  action: string | ActivityDefinition<TContext, TEvent>
): ActivityDefinition<TContext, TEvent>;
declare export var toActionObjects: <TContext, TEvent: EventObject>(
  action: Action<TContext, TEvent>[] | void,
  actionFunctionMap?: Record<
    string,
    ActionObject<TContext, TEvent> | ActionFunction<TContext, TEvent>
  > | void
) => ActionObject<TContext, TEvent>[];
/**
 * Raises an event. This places the event in the internal event queue, so that
 * the event is immediately consumed by the machine in the current step.
 * @param eventType The event to raise.
 */
declare export function raise<TContext, TEvent: EventObject>(
  event: Event<TEvent>
): RaiseEvent<TContext, TEvent>;

/**
 * Sends an event. This returns an action that will be read by an interpreter to
 * send the event in the next step, after the current step is finished executing.
 * @param event The event to send.
 * @param options Options to pass into the send event:
 * - `id` - The unique send event identifier (used with `cancel()`).
 * - `delay` - The number of milliseconds to delay the sending of the event.
 * - `target` - The target of this event (by default, the machine the event was sent from).
 */
declare export function send<TContext, TEvent: EventObject>(
  event: Event<TEvent> | SendExpr<TContext, TEvent>,
  options?: SendActionOptions<TContext, TEvent>
): SendAction<TContext, TEvent>;
declare export function resolveSend<TContext, TEvent: EventObject>(
  action: SendAction<TContext, TEvent>,
  ctx: TContext,
  event: TEvent
): SendActionObject<TContext, OmniEventObject<TEvent>>;

/**
 * Sends an event to this machine's parent machine.
 * @param event The event to send to the parent machine.
 * @param options Options to pass into the send event.
 */
declare export function sendParent<TContext, TEvent: EventObject>(
  event: Event<TEvent> | SendExpr<TContext, TEvent>,
  options?: SendActionOptions<TContext, TEvent>
): SendAction<TContext, TEvent>;

/**
 * @param expr The expression function to evaluate which will be logged.
 * Takes in 2 arguments:
 * - `ctx` - the current state context
 * - `event` - the event that caused this action to be executed.
 * @param label The label to give to the logged expression.
 */
declare export function log<TContext, TEvent: EventObject>(
  expr?: (ctx: TContext, event: TEvent) => any,
  label?: string
): {
  type: ActionTypes,
  label: string | void,
  expr: (ctx: TContext, event: TEvent) => any
};

/**
 * Cancels an in-flight `send(...)` action. A canceled sent action will not
 * be executed, nor will its event be sent, unless it has already been sent
 * (e.g., if `cancel(...)` is called after the `send(...)` action's `delay`).
 * @param sendId The `id` of the `send(...)` action to cancel.
 */
declare export var cancel: (sendId: string | number) => CancelAction;
/**
 * Starts an activity.
 * @param activity The activity to start.
 */
declare export function start<TContext, TEvent: EventObject>(
  activity: string | ActivityDefinition<TContext, TEvent>
): ActivityActionObject<TContext, TEvent>;

/**
 * Stops an activity.
 * @param activity The activity to stop.
 */
declare export function stop<TContext, TEvent: EventObject>(
  activity: string | ActivityDefinition<TContext, TEvent>
): ActivityActionObject<TContext, TEvent>;

/**
 * Updates the current context of the machine.
 * @param assignment An object that represents the partial context to update.
 */
declare export var assign: <TContext, TEvent: EventObject>(
  assignment:
    | Assigner<TContext, TEvent>
    | $Shape<
        $ObjMapi<
          TContext,
          <K>(
            K
          ) =>
            | ((context: TContext, event: TEvent) => $ElementType<TContext, K>)
            | $ElementType<TContext, K>
        >
      >
) => AssignAction<TContext, TEvent>;
declare export function isActionObject<TContext, TEvent: EventObject>(
  action: Action<TContext, TEvent>
): boolean;

/**
 * Returns an event type that represents an implicit event that
 * is sent after the specified `delay`.
 * @param delayRef The delay in milliseconds
 * @param id The state node ID where this event is handled
 */
declare export function after(delayRef: number | string, id?: string): string;

/**
 * Returns an event that represents that a final state node
 * has been reached in the parent state node.
 * @param id The final state node's parent state node `id`
 * @param data The data to pass into the event
 */
declare export function done(id: string, data?: any): DoneEventObject;

/**
 * Returns an event that represents that an invoked service has terminated.
 *
 * An invoked service is terminated when it has reached a top-level final state node,
 * but not when it is canceled.
 * @param id The final state node ID
 * @param data The data to pass into the event
 */
declare export function doneInvoke(id: string, data?: any): DoneEvent;
declare export function error(data: any, src: string): ErrorExecutionEvent;
