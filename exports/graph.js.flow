/**
 * Flowtype definitions for graph
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.8.0
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 * @flow
 */

import { StateNode, State } from "./index";
import {
  StateValue,
  Edge,
  PathMap,
  PathItem,
  PathsItem,
  PathsMap,
  AdjacencyMap,
  DefaultContext,
  ValueAdjacencyMap,
  EventObject,
  StateMachine
} from "./types";
declare export function getNodes(node: StateNode): StateNode[];
declare export function getEventEdges<TContext, TEvent: EventObject>(
  node: StateNode<TContext>,
  event: string
): Array<Edge<TContext, TEvent>>;
declare export function getEdges<TContext, TEvent: EventObject>(
  node: StateNode<TContext>,
  options?: {
    depth: null | number
  }
): Array<Edge<TContext, TEvent>>;
declare export function getAdjacencyMap<TContext>(
  node: StateNode<TContext>,
  context?: TContext
): AdjacencyMap;
declare export function deserializeStateString(
  valueContextString: string
): {
  value: StateValue,
  context: any
};
declare export function serializeState<TContext>(
  state: State<TContext>
): string;
declare export function serializeEvent<TEvent: EventObject>(
  event: TEvent
): string;
declare export function deserializeEventString<TEvent: EventObject>(
  eventString: string
): TEvent;
export interface ValueAdjMapOptions<TContext, TEvent: EventObject> {
  events: $ObjMapi<
    { [k: $PropertyType<TEvent, "type">]: any },
    <K>(
      K
    ) => Array<
      TEvent & {
        type: K
      }
    >
  >;
  filter: (state: State<TContext>) => boolean;
  stateSerializer: (state: State<TContext>) => string;
  eventSerializer: (event: TEvent) => string;
}
declare export class ValueAdjacency<TContext, TEvent: EventObject> {
  machine: StateMachine<TContext, any, TEvent>;
  mapping: ValueAdjacencyMap<TContext, TEvent>;
  options: ValueAdjMapOptions<TContext, TEvent>;
  constructor(
    machine: StateMachine<TContext, any, TEvent>,
    options?: $Shape<ValueAdjMapOptions<TContext, TEvent>>
  ): this;
  reaches(stateValue: StateValue, context: TContext): boolean;
}
declare export function getValueAdjacencyMap<TContext, TEvent: EventObject>(
  node: StateNode<TContext, any, TEvent>,
  options?: $Shape<ValueAdjMapOptions<TContext, TEvent>>
): ValueAdjacencyMap<TContext, TEvent>;
declare export function getShortestValuePaths<TContext, TEvent: EventObject>(
  machine: StateNode<TContext, any, TEvent>,
  options?: ValueAdjMapOptions<TContext, TEvent>
): PathMap<TContext, TEvent>;
declare export function getShortestPathsAsArray<TContext, TEvent: EventObject>(
  machine: StateNode<TContext, any, TEvent>
): Array<PathItem<TContext, TEvent>>;
declare export function getSimplePaths<TContext, TEvent: EventObject>(
  machine: StateNode<TContext>,
  options?: $Shape<ValueAdjMapOptions<TContext, TEvent>>
): PathsMap<TContext, TEvent>;
declare export function getSimplePathsAsArray<TContext, TEvent: EventObject>(
  machine: StateNode<TContext>,
  options?: ValueAdjMapOptions<TContext, TEvent>
): Array<PathsItem<TContext, TEvent>>;
