/**
 * Flowtype definitions for interpreter
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.8.0
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 * @flow
 */

import {
  StateMachine,
  Event,
  EventObject,
  DefaultContext,
  StateSchema,
  OmniEventObject,
  OmniEvent,
  Sender,
  StateValue,
  InterpreterOptions,
  SingleOrArray
} from "./types";
import { State } from "./State";
export type StateListener<TContext, TEvent: EventObject> = (
  state: State<TContext, TEvent>,
  event: OmniEventObject<TEvent>
) => void;
export type ContextListener<TContext = DefaultContext> = (
  context: TContext,
  prevContext: TContext | void
) => void;
export type EventListener = (event: EventObject) => void;
export type Listener = () => void;
export interface Clock {
  setTimeout(fn: (...args: any[]) => void, timeout: number): any;
  clearTimeout(id: any): void;
}
declare export class SimulatedClock mixins SimulatedClock {
  now(): number;
  setTimeout(fn: (...args: any[]) => void, timeout: number): number;
  clearTimeout(id: number): void;
}
export interface Actor {
  send: Sender<any>;
  stop: (() => void) | void;
}
declare export class Interpreter<
  TContext,
  TStateSchema: StateSchema = any,
  TEvent: EventObject = EventObject
> {
  machine: StateMachine<TContext, TStateSchema, TEvent>;

  /**
   * The default interpreter options:
   *
   * - `clock` uses the global `setTimeout` and `clearTimeout` functions
   * - `logger` uses the global `console.log()` method
   */
  static defaultOptions: InterpreterOptions;

  /**
   * The current state of the interpreted machine.
   */
  state: State<TContext, TEvent>;

  /**
   * The clock that is responsible for setting and clearing timeouts, such as delayed events and transitions.
   */
  clock: Clock;
  options: $ReadOnly<InterpreterOptions>;
  parent: Interpreter<any>;
  id: string;

  /**
   * Creates a new Interpreter instance (i.e., service) for the given machine with the provided options, if any.
   * @param machine The machine to be interpreted
   * @param options Interpreter options
   */
  constructor(
    machine: StateMachine<TContext, TStateSchema, TEvent>,
    options?: $Shape<InterpreterOptions>
  ): this;
  static interpret: typeof interpret;

  /**
   * The initial state of the statechart.
   */
  initialState: State<TContext, TEvent>;

  /**
   * Executes the actions of the given state, with that state's `context` and `event`.
   * @param state The state whose actions will be executed
   */
  execute(state: State<TContext, TEvent>): void;
  onTransition(
    listener: StateListener<TContext, TEvent>
  ): Interpreter<TContext, TStateSchema, TEvent>;

  /**
   * Adds an event listener that is notified whenever an event is sent to the running interpreter.
   * @param listener The event listener
   */
  onEvent(listener: EventListener): Interpreter<TContext, TStateSchema, TEvent>;

  /**
   * Adds an event listener that is notified whenever a `send` event occurs.
   * @param listener The event listener
   */
  onSend(listener: EventListener): Interpreter<TContext, TStateSchema, TEvent>;

  /**
   * Adds a context listener that is notified whenever the state context changes.
   * @param listener The context listener
   */
  onChange(
    listener: ContextListener<TContext>
  ): Interpreter<TContext, TStateSchema, TEvent>;

  /**
   * Adds a listener that is notified when the machine is stopped.
   * @param listener The listener
   */
  onStop(listener: Listener): Interpreter<TContext, TStateSchema, TEvent>;

  /**
   * Adds a state listener that is notified when the statechart has reached its final state.
   * @param listener The state listener
   */
  onDone(listener: EventListener): Interpreter<TContext, TStateSchema, TEvent>;

  /**
   * Removes a listener.
   * @param listener The listener to remove
   */
  off(
    listener: (...args: any[]) => void
  ): Interpreter<TContext, TStateSchema, TEvent>;

  /**
   * Alias for Interpreter.prototype.start
   */
  init: (
    initialState?: string | $Exports<"./types"> | State<TContext, TEvent> | void
  ) => Interpreter<TContext, TStateSchema, TEvent>;

  /**
   * Starts the interpreter from the given state, or the initial state.
   * @param initialState The state to start the statechart from
   */
  start(
    initialState?: State<TContext, TEvent> | StateValue
  ): Interpreter<TContext, TStateSchema, TEvent>;

  /**
   * Stops the interpreter and unsubscribe all listeners.
   *
   * This will also notify the `onStop` listeners.
   */
  stop(): Interpreter<TContext, TStateSchema, TEvent>;

  /**
   * Sends an event to the running interpreter to trigger a transition.
   *
   * An array of events (batched) can be sent as well, which will send all
   * batched events to the running interpreter. The listeners will be
   * notified only **once** when all events are processed.
   * @param event The event(s) to send
   */
  send: (
    event: SingleOrArray<OmniEvent<TEvent>>,
    payload?:
      | (Record<string, any> & {
          type?: void
        })
      | void
  ) => State<TContext, TEvent>;

  /**
   * Returns a send function bound to this interpreter instance.
   * @param event The event to be sent by the sender.
   */
  sender: (event: Event<TEvent>) => () => State<TContext, TEvent>;
  sendTo: (event: OmniEventObject<TEvent>, to: string) => void;

  /**
   * Returns the next state given the interpreter's current state and the event.
   *
   * This is a pure method that does _not_ update the interpreter's state.
   * @param event The event to determine the next state
   */
  nextState(event: OmniEvent<TEvent>): State<TContext, TEvent>;
}
/**
 * Creates a new Interpreter instance for the given machine with the provided options, if any.
 * @param machine The machine to interpret
 * @param options Interpreter options
 */
declare export function interpret<
  TContext,
  TStateSchema: StateSchema,
  TEvent: EventObject
>(
  machine: StateMachine<TContext, TStateSchema, TEvent>,
  options?: $Shape<InterpreterOptions>
): Interpreter<TContext, TStateSchema, TEvent>;
