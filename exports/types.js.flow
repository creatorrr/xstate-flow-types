/**
 * Flowtype definitions for types
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.8.0
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 * @flow
 */

import { StateNode } from "./StateNode";
import { State } from "./State";
import { StateTree } from "./StateTree";
import { Interpreter, Clock } from "./interpreter";
export type EventType = string;
export type ActionType = string;
export type MetaObject = Record<string, any>;
/**
 * The full definition of an event, with a string `type`.
 */
export interface EventObject {
  /**
   * The type of event that is sent.
   */
  type: string;

  /**
   * The unique ID that identifies this specific event instance.
   */
  id?: string | number;
  [other: string]: any;
}
/**
 * The full definition of an action, with a string `type` and an
 * `exec` implementation function.
 */
export interface ActionObject<TContext, TEvent: EventObject> {
  /**
   * The type of action that is executed.
   */
  type: string;

  /**
   * The implementation for executing the action.
   */
  exec?: ActionFunction<TContext, TEvent>;
  [other: string]: any;
}
export type DefaultContext = Record<string, any> | void;
/**
 * The specified string event types or the specified event objects.
 */
export type Event<TEvent: EventObject> = $PropertyType<TEvent, "type"> | TEvent;
/**
 * Represents the specified event types or the full event objects,
 * as well as the built in event types and/or objects.
 */
export type OmniEvent<TEvent: EventObject> =
  | $PropertyType<TEvent, "type">
  | $PropertyType<BuiltInEvent<TEvent>, "type">
  | OmniEventObject<TEvent>;
export type ExecMeta<TContext, TEvent: EventObject> = {
  action: ActionObject<TContext, TEvent>
} & StateMeta<TContext, TEvent>;
export interface ActionFunction<TContext, TEvent: EventObject> {
  (
    context: TContext,
    event: TEvent,
    meta: ExecMeta<TContext, TEvent>
  ): any | void;
  name: string;
}
export type Action<TContext, TEvent: EventObject> =
  | ActionType
  | ActionObject<TContext, TEvent>
  | ActionFunction<TContext, TEvent>;
export type StateKey = string | State<any>;
export interface StateValueMap {
  [key: string]: StateValue;
}
/**
 * The string or object representing the state value relative to the parent state node.
 *
 * - For a child atomic state node, this is a string, e.g., `"pending"`.
 * - For complex state nodes, this is an object, e.g., `{ success: "someChildState" }`.
 */
export type StateValue = string | StateValueMap;
export interface HistoryValue {
  states: Record<string, HistoryValue | void>;
  current: StateValue | void;
}
export type ConditionPredicate<TContext, TEvent: EventObject> = (
  context: TContext,
  event: TEvent,
  meta: GuardMeta<TContext, TEvent>
) => boolean;
export interface GuardPredicate<TContext, TEvent: EventObject> {
  type: "xstate.cond";
  predicate: ConditionPredicate<TContext, OmniEventObject<TEvent>>;
}
export type Guard<TContext, TEvent: EventObject> =
  | GuardPredicate<TContext, TEvent>
  | (Record<string, any> & {
      type: string
    });
export type GuardMeta<TContext, TEvent: EventObject> = {
  cond: Guard<TContext, TEvent>
} & StateMeta<TContext, TEvent>;
export type Condition<TContext, TEvent: EventObject> =
  | string
  | ConditionPredicate<TContext, TEvent>
  | Guard<TContext, TEvent>;
export interface TransitionConfig<TContext, TEvent: EventObject> {
  cond?: Condition<TContext, TEvent>;
  actions?: SingleOrArray<Action<TContext, TEvent>>;
  in?: StateValue;
  internal?: boolean;
  target?: string | string[];
  meta?: Record<string, any>;
}
export type TargetTransitionConfig<TContext, TEvent: EventObject> = {
  target: string | string[] | void
} & TransitionConfig<TContext, TEvent>;
export type ConditionalTransitionConfig<
  TContext,
  TEvent: EventObject = EventObject
> = Array<TransitionConfig<TContext, TEvent>>;
export type Transition<TContext, TEvent: EventObject = EventObject> =
  | string
  | TransitionConfig<TContext, TEvent>
  | ConditionalTransitionConfig<TContext, TEvent>;
export type DisposeActivityFunction = () => void;
export type ActivityConfig<TContext, TEvent: EventObject> = (
  ctx: TContext,
  activity: ActivityDefinition<TContext, TEvent>
) => DisposeActivityFunction | void;
export type Activity<TContext, TEvent: EventObject> =
  | string
  | ActivityDefinition<TContext, TEvent>;
export type ActivityDefinition<TContext, TEvent: EventObject> = {
  id: string,
  type: string
} & ActionObject<TContext, TEvent>;
export type Sender<TEvent: EventObject> = (event: Event<TEvent>) => void;
export type Receiver<TEvent: EventObject> = (
  listener: (event: TEvent) => void
) => void;
export type InvokeCallback = (
  sender: Sender<any>,
  onEvent: Receiver<EventObject>
) => any;
/**
 * Returns either a Promises or a callback handler (for streams of events) given the
 * machine's current `context` and `event` that invoked the service.
 *
 * For Promises, the only events emitted to the parent will be:
 * - `done.invoke.<id>` with the `data` containing the resolved payload when the promise resolves, or:
 * - `error.execution` with the `data` containing the caught error, and `src` containing the service `id`.
 *
 * For callback handlers, the `sender` will be provided, which will send events to the parent service.
 * @param context The current machine `context`
 * @param event The event that invoked the service
 */
export type InvokeCreator<TFinalContext, TContext> = (
  context: TContext,
  event: EventObject
) =>
  | PromiseLike<TFinalContext>
  | StateMachine<TFinalContext, any, any>
  | InvokeCallback;
export type InvokeDefinition<TContext, TEvent: EventObject> = {
  /**
   * The source of the machine to be invoked, or the machine itself.
   */
  src: string,

  /**
   * If `true`, events sent to the parent service will be forwarded to the invoked service.
   *
   * Default: `false`
   */
  forward?: boolean,

  /**
   * Data from the parent machine's context to set as the (partial or full) context
   * for the invoked child machine.
   *
   * Data should be mapped to match the child machine's context shape.
   */
  data?: Mapper<TContext, TEvent> | PropertyMapper<TContext, TEvent>
} & ActivityDefinition<TContext, TEvent>;
export interface Delay {
  id: string;

  /**
   * The time to delay the event, in milliseconds.
   */
  delay: number;
}
export type DelayedTransitions<TContext, TEvent: EventObject> =
  | Record<
      string | number,
      string | SingleOrArray<TransitionConfig<TContext, TEvent>>
    >
  | Array<
      TransitionConfig<TContext, TEvent> & {
        delay: number | string | Expr<TContext, TEvent, number>
      }
    >;
export type StateTypes =
  | "atomic"
  | "compound"
  | "parallel"
  | "final"
  | "history"
  | string;
export type SingleOrArray<T> = T[] | T;
export type StateNodesConfig<
  TContext,
  TStateSchema: StateSchema,
  TEvent: EventObject
> = $ObjMapi<
  $PropertyType<TStateSchema, "states">,
  <K>(
    K
  ) => StateNode<
    TContext,
    $ElementType<$PropertyType<TStateSchema, "states">, K>,
    TEvent
  >
>;
export type StatesConfig<
  TContext,
  TStateSchema: StateSchema,
  TEvent: EventObject
> = $ObjMapi<
  $PropertyType<TStateSchema, "states">,
  <K>(
    K
  ) => StateNodeConfig<
    TContext,
    $ElementType<$PropertyType<TStateSchema, "states">, K>,
    TEvent
  >
>;
export type StatesDefinition<
  TContext,
  TStateSchema: StateSchema,
  TEvent: EventObject
> = $ObjMapi<
  $PropertyType<TStateSchema, "states">,
  <K>(
    K
  ) => StateNodeDefinition<
    TContext,
    $ElementType<$PropertyType<TStateSchema, "states">, K>,
    TEvent
  >
>;
export type TransitionsConfig<TContext, TEvent: EventObject> = $ObjMapi<
  {
    [k:
      | $PropertyType<TEvent, "type">
      | $PropertyType<BuiltInEvent<TEvent>, "type">]: any
  },
  <K>(
    K
  ) =>
    | string
    | number
    | StateNode<TContext>
    | SingleOrArray<
        TransitionConfig<
          TContext,
          Extract<
            TEvent,
            {
              type: K
            }
          >
        >
      >
>;
export type TransitionsDefinition<TContext, TEvent: EventObject> = $ObjMapi<
  { [k: $PropertyType<TEvent, "type">]: any },
  <K>(
    K
  ) => Array<
    TransitionDefinition<
      TContext,
      Extract<
        TEvent,
        {
          type: K
        }
      >
    >
  >
>;
export type InvokeConfig<TContext, TEvent: EventObject> =
  | {
      /**
       * The unique identifier for the invoked machine. If not specified, this
       * will be the machine's own `id`, or the URL (from `src`).
       */
      id?: string,

      /**
       * The source of the machine to be invoked, or the machine itself.
       */
      src: string | StateMachine<any, any, any> | InvokeCreator<any, TContext>,

      /**
       * If `true`, events sent to the parent service will be forwarded to the invoked service.
       *
       * Default: `false`
       */
      forward?: boolean,

      /**
       * Data from the parent machine's context to set as the (partial or full) context
       * for the invoked child machine.
       *
       * Data should be mapped to match the child machine's context shape.
       */
      data?: Mapper<TContext, TEvent> | PropertyMapper<TContext, TEvent>,

      /**
       * The transition to take upon the invoked child machine reaching its final top-level state.
       */
      onDone?:
        | string
        | SingleOrArray<TransitionConfig<TContext, DoneInvokeEvent<any>>>,

      /**
       * The transition to take upon the invoked child machine sending an error event.
       */
      onError?:
        | string
        | SingleOrArray<TransitionConfig<TContext, DoneInvokeEvent<any>>>
    }
  | StateMachine<any, any, any>;
export type InvokesConfig<TContext, TEvent: EventObject> = SingleOrArray<
  InvokeConfig<TContext, TEvent>
>;
export interface StateNodeConfig<
  TContext,
  TStateSchema: StateSchema,
  TEvent: EventObject
> {
  /**
   * The relative key of the state node, which represents its location in the overall state value.
   * This is automatically determined by the configuration shape via the key where it was defined.
   */
  key?: string;

  /**
   * The initial state node key.
   */
  initial?: $Keys<$PropertyType<TStateSchema, "states">> | void;

  /**
   * @deprecated
   */
  parallel?: boolean | void;

  /**
   * The type of this state node:
   *
   *   - `'atomic'` - no child state nodes
   *   - `'compound'` - nested child state nodes (XOR)
   *   - `'parallel'` - orthogonal nested child state nodes (AND)
   *   - `'history'` - history state node
   *   - `'final'` - final state node
   */
  type?: StateTypes;

  /**
   * The initial context (extended state) of the machine.
   */
  context?: TContext;

  /**
   * Indicates whether the state node is a history state node, and what
   * type of history:
   * shallow, deep, true (shallow), false (none), undefined (none)
   */
  history?: "shallow" | "deep" | boolean | void;

  /**
   * The mapping of state node keys to their state node configurations (recursive).
   */
  states?: StatesConfig<TContext, TStateSchema, TEvent> | void;

  /**
   * The services to invoke upon entering this state node. These services will be stopped upon exiting this state node.
   */
  invoke?: InvokesConfig<TContext, TEvent>;

  /**
   * The mapping of event types to their potential transition(s).
   */
  on?: TransitionsConfig<TContext, TEvent>;

  /**
   * The action(s) to be executed upon entering the state node.
   * @deprecated Use `entry` instead.
   */
  onEntry?: SingleOrArray<Action<TContext, TEvent>>;

  /**
   * The action(s) to be executed upon entering the state node.
   */
  entry?: SingleOrArray<Action<TContext, TEvent>>;

  /**
   * The action(s) to be executed upon exiting the state node.
   * @deprecated Use `exit` instead.
   */
  onExit?: SingleOrArray<Action<TContext, TEvent>>;

  /**
   * The action(s) to be executed upon exiting the state node.
   */
  exit?: SingleOrArray<Action<TContext, TEvent>>;

  /**
   * The potential transition(s) to be taken upon reaching a final child state node.
   *
   * This is equivalent to defining a `[done(id)]` transition on this state node's `on` property.
   */
  onDone?: string | SingleOrArray<TransitionConfig<TContext, DoneEventObject>>;

  /**
   * The mapping (or array) of delays (in milliseconds) to their potential transition(s).
   * The delayed transitions are taken after the specified delay in an interpreter.
   */
  after?: DelayedTransitions<TContext, TEvent>;

  /**
   * The activities to be started upon entering the state node,
   * and stopped upon exiting the state node.
   */
  activities?: SingleOrArray<Activity<TContext, TEvent>>;

  /**
   * @private
   */
  parent?: StateNode<TContext>;
  strict?: boolean | void;

  /**
   * The meta data associated with this state node, which will be returned in State instances.
   */
  meta?: /* Flow doesn't support conditional types, use $Call utility type */ any;

  /**
   * The data sent with the "done.state._id_" event if this is a final state node.
   *
   * The data will be evaluated with the current `context` and placed on the `.data` property
   * of the event.
   */
  data?: Mapper<TContext, TEvent> | PropertyMapper<TContext, TEvent>;

  /**
   * The unique ID of the state node, which can be referenced as a transition target via the
   * `#id` syntax.
   */
  id?: string | void;

  /**
   * The string delimiter for serializing the path to a string. The default is "."
   */
  delimiter?: string;

  /**
   * The order this state node appears. Corresponds to the implicit SCXML document order.
   */
  order?: number;
}
export type StateNodeDefinition<
  TContext,
  TStateSchema: StateSchema,
  TEvent: EventObject
> = {
  id: string,
  version: string | void,
  key: string,
  type: StateTypes,
  initial: $PropertyType<
    StateNodeConfig<TContext, TStateSchema, TEvent>,
    "initial"
  >,
  history: boolean | "shallow" | "deep" | void,
  states: StatesDefinition<TContext, TStateSchema, TEvent>,
  on: TransitionsDefinition<TContext, TEvent>,
  onEntry: Array<ActionObject<TContext, TEvent>>,
  onExit: Array<ActionObject<TContext, TEvent>>,
  activities: Array<ActivityDefinition<TContext, TEvent>>,
  meta: any,
  order: number,
  data?: $PropertyType<FinalStateNodeConfig<TContext, TEvent>, "data">
} & StateNodeConfig<TContext, TStateSchema, TEvent>;
export type AnyStateNodeDefinition = StateNodeDefinition<any, any, any>;
export type AtomicStateNodeConfig<TContext, TEvent: EventObject> = {
  initial?: void,
  parallel?: false | void,
  states?: void,
  onDone?: void
} & StateNodeConfig<TContext, StateSchema, TEvent>;
export type HistoryStateNodeConfig<TContext, TEvent: EventObject> = {
  history: "shallow" | "deep" | true,
  target: StateValue | void
} & AtomicStateNodeConfig<TContext, TEvent>;
export type FinalStateNodeConfig<TContext, TEvent: EventObject> = {
  type: "final",

  /**
   * The data to be sent with the "done.state.<id>" event. The data can be
   * static or dynamic (based on assigners).
   */
  data?: Assigner<TContext, TEvent> | PropertyAssigner<TContext, TEvent> | any
} & AtomicStateNodeConfig<TContext, TEvent>;
export type CompoundStateNodeConfig<
  TContext,
  TStateSchema: StateSchema,
  TEvent: EventObject
> = {
  parallel?: boolean,
  states: $PropertyType<
    StateNodeConfig<TContext, TStateSchema, TEvent>,
    "states"
  >
} & StateNodeConfig<TContext, TStateSchema, TEvent>;
export type SimpleOrCompoundStateNodeConfig<
  TContext,
  TStateSchema: StateSchema,
  TEvent: EventObject
> =
  | AtomicStateNodeConfig<TContext, TEvent>
  | CompoundStateNodeConfig<TContext, TStateSchema, TEvent>;
export type ActionFunctionMap<TContext, TEvent: EventObject> = Record<
  string,
  ActionObject<TContext, TEvent> | ActionFunction<TContext, TEvent>
>;
export type ServiceConfig<TContext> =
  | string
  | StateMachine<any, any, any>
  | InvokeCreator<any, TContext>;
export type DelayConfig<TContext, TEvent: EventObject> =
  | number
  | Expr<TContext, OmniEventObject<TEvent>, number>;
export interface MachineOptions<TContext, TEvent: EventObject> {
  guards: Record<string, ConditionPredicate<TContext, TEvent>>;
  actions: ActionFunctionMap<TContext, TEvent>;
  activities: Record<string, ActivityConfig<TContext, TEvent>>;
  services: Record<string, ServiceConfig<TContext>>;
  delays: Record<string, DelayConfig<TContext, TEvent>>;
  updater: Updater<TContext, TEvent>;
}
export type MachineConfig<
  TContext,
  TStateSchema: StateSchema,
  TEvent: EventObject
> = {
  /**
   * The initial context (extended state)
   */
  context?: TContext,

  /**
   * The machine's own version.
   */
  version?: string
} & CompoundStateNodeConfig<TContext, TStateSchema, TEvent>;
export type StandardMachineConfig<
  TContext,
  TStateSchema: StateSchema,
  TEvent: EventObject
> = {} & CompoundStateNodeConfig<TContext, TStateSchema, TEvent>;
export type ParallelMachineConfig<
  TContext,
  TStateSchema: StateSchema,
  TEvent: EventObject
> = {
  initial?: void,
  type?: "parallel"
} & CompoundStateNodeConfig<TContext, TStateSchema, TEvent>;
export interface EntryExitEffectMap<TContext, TEvent: EventObject> {
  entry: Array<ActionObject<TContext, TEvent>>;
  exit: Array<ActionObject<TContext, TEvent>>;
}
export type HistoryStateNode<TContext> = {
  history: "shallow" | "deep",
  target: StateValue | void
} & StateNode<TContext>;
export type StateMachine<
  TContext,
  TStateSchema: StateSchema,
  TEvent: EventObject
> = {
  id: string,
  states: $PropertyType<StateNode<TContext, TStateSchema, TEvent>, "states">
} & StateNode<TContext, TStateSchema, TEvent>;
export interface ActionMap<TContext, TEvent: EventObject> {
  onEntry: Array<Action<TContext, TEvent>>;
  actions: Array<Action<TContext, TEvent>>;
  onExit: Array<Action<TContext, TEvent>>;
}
export interface EntryExitStates<TContext> {
  entry: Set<StateNode<TContext>>;
  exit: Set<StateNode<TContext>>;
}
export interface EntryExitStateArrays<TContext> {
  entry: Array<StateNode<TContext>>;
  exit: Array<StateNode<TContext>>;
}
export interface ActivityMap {
  [activityKey: string]: ActivityDefinition<any, any> | false;
}
export interface StateTransition<TContext, TEvent: EventObject> {
  tree: StateTree | void;

  /**
   * The source state that preceded the transition.
   */
  source: State<TContext> | void;
  reentryStates: Set<StateNode<TContext>> | void;
  actions: Array<ActionObject<TContext, TEvent>>;
}
export interface TransitionData<TContext, TEvent: EventObject> {
  value: StateValue | void;
  actions: ActionMap<TContext, TEvent>;
  activities?: ActivityMap;
}
declare export var ActionTypes: {|
  +Start: "xstate.start", // "xstate.start"
  +Stop: "xstate.stop", // "xstate.stop"
  +Raise: "xstate.raise", // "xstate.raise"
  +Send: "xstate.send", // "xstate.send"
  +Cancel: "xstate.cancel", // "xstate.cancel"
  +NullEvent: "", // ""
  +Assign: "xstate.assign", // "xstate.assign"
  +After: "xstate.after", // "xstate.after"
  +DoneState: "done.state", // "done.state"
  +DoneInvoke: "done.invoke", // "done.invoke"
  +Log: "xstate.log", // "xstate.log"
  +Init: "xstate.init", // "xstate.init"
  +Invoke: "xstate.invoke", // "xstate.invoke"
  +ErrorExecution: "error.execution", // "error.execution"
  +ErrorCommunication: "error.communication" // "error.communication"
|};
export interface RaisedEvent<TEvent: EventObject> {
  type: typeof ActionTypes.Raise;
  event: TEvent;
}
export type RaiseEvent<TContext, TEvent: EventObject> = {
  event: Event<TEvent>
} & ActionObject<TContext, TEvent>;
export type DoneInvokeEvent<TData> = {
  data: TData
} & EventObject;
export type ErrorExecutionEvent = {
  src: string,
  type: typeof ActionTypes.ErrorExecution,
  data: any
} & EventObject;
export type DoneEventObject = {
  data?: any,
  toString(): string
} & EventObject;
export type DoneEvent = DoneEventObject & string;
export type BuiltInEvent<TEvent: EventObject> =
  | {
      type: typeof ActionTypes.NullEvent
    }
  | {
      type: typeof ActionTypes.Init
    }
  | RaisedEvent<TEvent>
  | ErrorExecutionEvent;
/**
 * Represents the specified events and the built-in internal events.
 */
export type OmniEventObject<TEvent: EventObject> =
  | TEvent
  | BuiltInEvent<TEvent>;
export type ActivityActionObject<TContext, TEvent: EventObject> = {
  type: typeof ActionTypes.Start | typeof ActionTypes.Stop,
  activity: ActivityDefinition<TContext, TEvent>,
  exec: ActionFunction<TContext, TEvent> | void
} & ActionObject<TContext, TEvent>;
export type SendAction<TContext, TEvent: EventObject> = {
  to: string | void,
  event: TEvent | SendExpr<TContext, TEvent>,
  delay?: number | string | Expr<TContext, TEvent, number>,
  id: string | number
} & ActionObject<TContext, TEvent>;
export type SendActionObject<TContext, TEvent: EventObject> = {
  to: string | void,
  event: TEvent,
  delay?: number | string,
  id: string | number
} & SendAction<TContext, TEvent>;
export type Expr<TContext, TEvent: EventObject, T> = (
  context: TContext,
  event: TEvent
) => T;
export type SendExpr<TContext, TEvent: EventObject> = (
  context: TContext,
  event: TEvent
) => OmniEvent<TEvent>;
declare export var SpecialTargets: {|
  +Parent: "#_parent", // "#_parent"
  +Internal: "#_internal" // "#_internal"
|};
export interface SendActionOptions<TContext, TEvent: EventObject> {
  id?: string | number;
  delay?: number | string | Expr<TContext, TEvent, number>;
  to?: string;
}
export type CancelAction = {
  sendId: string | number
} & ActionObject<any, any>;
export type Assigner<TContext, TEvent: EventObject> = (
  context: TContext,
  event: TEvent
) => $Shape<TContext>;
export type PropertyAssigner<TContext, TEvent: EventObject> = $Shape<
  $ObjMapi<
    TContext,
    <K>(
      K
    ) =>
      | ((context: TContext, event: TEvent) => $ElementType<TContext, K>)
      | $ElementType<TContext, K>
  >
>;
export type Mapper<TContext, TEvent: EventObject> = (
  context: TContext,
  event: TEvent
) => any;
export type PropertyMapper<TContext, TEvent: EventObject> = $Shape<{
  [key: string]: ((context: TContext, event: TEvent) => any) | any
}>;
export type Updater<
  TContext,
  TEvent: EventObject,
  TAssignAction: AnyAssignAction<TContext, TEvent> = AnyAssignAction<
    TContext,
    TEvent
  >
> = (
  context: TContext,
  event: OmniEventObject<TEvent>,
  assignActions: TAssignAction[]
) => TContext;
export type AnyAssignAction<TContext, TEvent: EventObject> = {
  assignment: any
} & ActionObject<TContext, TEvent>;
export type AssignAction<TContext, TEvent: EventObject> = {
  assignment: Assigner<TContext, TEvent> | PropertyAssigner<TContext, TEvent>
} & ActionObject<TContext, TEvent>;
export type TransitionDefinition<TContext, TEvent: EventObject> = {
  actions: Array<ActionObject<TContext, TEvent>>,
  cond?: Guard<TContext, TEvent>,
  event: string
} & TransitionConfig<TContext, TEvent>;
export type DelayedTransitionDefinition<TContext, TEvent: EventObject> = {
  delay: number | string | Expr<TContext, TEvent, number>
} & TransitionDefinition<TContext, TEvent>;
export interface Edge<
  TContext,
  TEvent: EventObject,
  TEventType: $PropertyType<TEvent, "type"> = string
> {
  event: TEventType;
  source: StateNode<TContext>;
  target: StateNode<TContext>;
  cond?: Condition<
    TContext,
    TEvent & {
      type: TEventType
    }
  >;
  actions: Array<Action<TContext, TEvent>>;
  meta?: MetaObject;
  transition: TransitionDefinition<TContext, TEvent>;
}
export interface NodesAndEdges<TContext, TEvent: EventObject> {
  nodes: StateNode[];
  edges: Array<Edge<TContext, TEvent, $PropertyType<TEvent, "type">>>;
}
export interface Segment<TContext, TEvent: EventObject> {
  /**
   * From state.
   */
  state: {
    value: StateValue,
    context: TContext
  };

  /**
   * Event from state.
   */
  event: TEvent;
}
export interface PathMap<TContext, TEvent: EventObject> {
  [key: string]: Array<Segment<TContext, TEvent>>;
}
export interface PathItem<TContext, TEvent: EventObject> {
  state: {
    value: StateValue,
    context: TContext
  };
  path: Array<Segment<TContext, TEvent>>;
}
export interface PathsItem<TContext, TEvent: EventObject> {
  state: {
    value: StateValue,
    context: TContext
  };
  paths: Array<Array<Segment<TContext, TEvent>>>;
}
export interface PathsMap<TContext, TEvent: EventObject> {
  [key: string]: PathsItem<TContext, TEvent>;
}
export interface TransitionMap {
  state: StateValue | void;
}
export interface AdjacencyMap {
  [stateId: string]: Record<string, TransitionMap>;
}
export interface ValueAdjacencyMap<TContext, TEvent: EventObject> {
  [stateId: string]: Record<string, State<TContext, TEvent>>;
}
export interface StateMeta<TContext, TEvent: EventObject> {
  state: State<TContext, TEvent>;
}
export interface StateInterface<
  TContext = DefaultContext,
  TEvent: EventObject = EventObject
> {
  value: StateValue;
  tree?: StateTree;
  history?: State<TContext>;
  historyValue?: HistoryValue | void;
  actions: Array<ActionObject<TContext, TEvent>>;
  activities: ActivityMap;
  meta: any;
  events: TEvent[];
  context: TContext;
  toStrings: () => string[];
}
export interface StateConfig<TContext, TEvent: EventObject> {
  value: StateValue;
  context: TContext;
  event: OmniEventObject<TEvent>;
  historyValue?: HistoryValue | void;
  history?: State<TContext>;
  actions?: Array<ActionObject<TContext, TEvent>>;
  activities?: ActivityMap;
  meta?: any;
  events?: TEvent[];
  tree?: StateTree;
}
export interface StateSchema {
  meta?: any;
  states?: Record<string | number, StateSchema>;
}
export interface InterpreterOptions {
  /**
   * Whether state actions should be executed immediately upon transition. Defaults to `true`.
   */
  execute: boolean;
  clock: Clock;
  logger: (...args: any[]) => void;
  parent?: Interpreter<any, any, any>;

  /**
   * If `true`, defers processing of sent events until the service
   * is initialized (`.start()`). Otherwise, an error will be thrown
   * for events sent to an uninitialized service.
   *
   * Default: `true`
   */
  deferEvents: boolean;

  /**
   * The custom `id` for referencing this service.
   */
  id?: string;

  /**
   * If `true`, states and events will be logged to Redux DevTools.
   *
   * Default: `false`
   */
  devTools: boolean;
}
