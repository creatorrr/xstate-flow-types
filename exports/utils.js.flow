/**
 * Flowtype definitions for utils
 * Generated by Flowgen from a Typescript Definition
 * Flowgen v1.8.0
 * Author: [Joar Wilk](http://twitter.com/joarwilk)
 * Repo: http://github.com/joarwilk/flowgen
 * @flow
 */

import {
  Event,
  StateValue,
  ActionType,
  Action,
  EventObject,
  StateInterface,
  PropertyMapper,
  Mapper,
  EventType,
  HistoryValue,
  OmniEventObject,
  AssignAction,
  ActionObject
} from "./types";
import { State } from "./State";
declare export function keys<T: { [key: string]: any }>(
  value: T
): Array<$Keys<T> & string>;
declare export function matchesState(
  parentStateId: StateValue,
  childStateId: StateValue,
  delimiter?: string
): boolean;
declare export function getEventType<TEvent: EventObject>(
  event: Event<TEvent>
): $PropertyType<TEvent, "type">;
declare export function getActionType(action: Action<any, any>): ActionType;
declare export function toStatePath(
  stateId: string | string[],
  delimiter: string
): string[];
declare export function toStateValue(
  stateValue: StateInterface<any> | StateValue | string[],
  delimiter: string
): StateValue;
declare export function pathToStateValue(statePath: string[]): StateValue;
declare export function mapValues<T, P>(
  collection: {
    [key: string]: T
  },
  iteratee: (
    item: T,
    key: string,
    collection: {
      [key: string]: T
    },
    i: number
  ) => P
): {
  [key: string]: P
};
declare export function mapFilterValues<T, P>(
  collection: {
    [key: string]: T
  },
  iteratee: (
    item: T,
    key: string,
    collection: {
      [key: string]: T
    }
  ) => P,
  predicate: (item: T) => boolean
): {
  [key: string]: P
};

/**
 * Retrieves a value at the given path.
 * @param props The deep path to the prop of the desired value
 */
declare export var path: <T: Record<string, any>>(props: string[]) => any;
/**
 * Retrieves a value at the given path via the nested accessor prop.
 * @param props The deep path to the prop of the desired value
 */
declare export function nestedPath<T: Record<string, any>>(
  props: string[],
  accessorProp: $Keys<T>
): (object: T) => T;
declare export var toStatePaths: (
  stateValue: string | $Exports<"./types"> | void
) => string[][];
declare export var pathsToStateValue: (paths: string[][]) => StateValue;
declare export function flatten<T>(array: T[][]): T[];
declare export function toArray<T>(value: T[] | T | void): T[];
declare export function mapContext<TContext, TEvent: EventObject>(
  mapper: Mapper<TContext, TEvent> | PropertyMapper<TContext, TEvent>,
  context: TContext,
  event: TEvent
): any;
declare export function isBuiltInEvent(eventType: EventType): boolean;
declare export function isPromiseLike(value: any): boolean;
declare export function partition<T, A: T, B: T>(
  items: T[],
  predicate: (item: T) => boolean
): [A[], B[]];
declare export function updateHistoryStates(
  hist: HistoryValue,
  stateValue: StateValue
): Record<string, HistoryValue | void>;
declare export function updateHistoryValue(
  hist: HistoryValue,
  stateValue: StateValue
): HistoryValue;
declare export function updateContext<TContext, TEvent: EventObject>(
  context: TContext,
  event: OmniEventObject<TEvent>,
  assignActions: Array<AssignAction<TContext, TEvent>>
): TContext;
declare export function bindActionToState<TC, TE: EventObject>(
  action: ActionObject<TC, TE>,
  state: State<TC, TE>
): ActionObject<TC, TE>;
declare var warn: (condition: boolean | Error, message: string) => void;
declare export { warn };
declare export function isArray(value: any): boolean;
declare export function isFunction(value: any): boolean;
declare export function isString(value: any): boolean;
